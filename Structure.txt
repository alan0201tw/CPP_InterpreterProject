Pascal Interpreter Project

Target Usage
{
    lexer = Lexer(text)
    parser = Parser(lexer)
    interpreter = Interpreter(parser)
    result = interpreter.interpret()
    print(result)
}

1. Lexer
{
    Contain Token-related library.
    Including TokenType enum and Token classes.

    Lexer itself contains a "get_next_token" method for external usage.

    All tokens contain a string value, can be a integer string or float string or character string.
}

2. Parser
{
    Contain AST_Node class and Operator class.
    Parser itself contains a "Parse" method, which will parse the tokens generated by Lexer to a AST.
}

3. Interpreter
{
    Visit the AST made by Parser, and operate using nodes.
    Finally output value.
}

Possible Structure : 

template <class T>
T Visit()
{
    return ConvertString<T>(value);
}

template <typename T>
T ConvertString( const std::string &data )
{
  if( !data.empty( ))
  {
    T ret;
    std::istringstream iss( data );
    if( data.find( "0x" ) != std::string::npos )
    {
      iss >> std::hex >> ret;
    }
    else
    {
      iss >> std::dec >> ret;
    }

    if( iss.fail( ))
    {
      std::cout << "Convert error: cannot convert string '" << data << "' to value" << std::endl;
      return T( );
    }
    return ret;
  }
  return T( );
}

TypeClass : 

    TypeBase > Void Type, Int type, Float type... etc
    {
        TypeBase contains a enum, each enum maps to a sub Type class.
        Each of them have basic opertators to each other.

        TypeBase + TypeBase > Int + Float > Float
                            > String + Int > String
    }

virtaul ValueBase
{
    void* data
    ValutType enum;
}

Visit()
{
    if node.type == Inte..
        (int*)data
}

IntValue : ValueBase
{
    
}

FloatValue